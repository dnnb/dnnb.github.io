<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>装饰器</title>
      <link href="/2018/06/29/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2018/06/29/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h2><p>装饰器对应的是设计模式中的装饰模式(Decorator Pattern)，是装饰者模式的实现方式之一，指在不改变原类文件和使用继承的情况下，通过创建一个包装对象，包裹真正的对象，动态的扩展一个对象的功能。</p><p>python的装饰器实际上就是一个可调用对象（函数对象，或者可调用类的实例，实例方法），可以让其它可调用对象在不做任何代码变动的前提下增加额外功能。</p><a id="more"></a><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><h3 id="什么是可调用对象？"><a href="#什么是可调用对象？" class="headerlink" title="什么是可调用对象？"></a>什么是可调用对象？</h3><p>在Python中，一切皆对象，包括用户定义和内置的变量、函数、类、方法、实例。由于正常程序员都知道函数、方法和类是可调用对象，就不进行解释了，在python中比较特殊一点的就是类实例也可能是个可调用对象，只要这个类实现了<code>__call__()</code>方法。</p><p>对于<code>__call__()</code>方法，可查看官方解释： <a href="https://docs.python.org/3/reference/datamodel.html?highlight=__call__#object.__call__" title="https://docs.python.org/3/reference/datamodel.html?highlight=__call__#object.__call__" target="_blank" rel="noopener">https://docs.python.org/3/reference/datamodel.html?highlight=<strong>call</strong>#object.<strong>call</strong></a></p><h3 id="可调用对象测试分析"><a href="#可调用对象测试分析" class="headerlink" title="可调用对象测试分析"></a>可调用对象测试分析</h3><p>在Python中，判断对象是否为可调用对象，可以用内置函数callable(object)进行检查，返回True就是可调用对象，返回False就是不可调用对象。</p><p>写个例子，测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clazz</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clazz_func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClazzCall</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'我被调用了! 参数是：&#123;0&#125;，&#123;1&#125;'</span>.format(args, kwargs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'----函数----'</span>)</span><br><span class="line">    print(<span class="string">'函数对象：'</span>, callable(func))</span><br><span class="line">    print(<span class="string">'匿名函数对象：'</span>, callable(<span class="keyword">lambda</span> x: x))</span><br><span class="line">    print(<span class="string">'\n----普通类----'</span>)</span><br><span class="line">    print(<span class="string">'类对象：'</span>, callable(Clazz))</span><br><span class="line">    print(<span class="string">'类实例：'</span>, callable(Clazz()))</span><br><span class="line">    print(<span class="string">'实例方法对象：'</span>, callable(Clazz().clazz_func))</span><br><span class="line">    print(<span class="string">'\n----重写类----'</span>)</span><br><span class="line">    print(<span class="string">'重写__call__方法的类对象：'</span>, callable(ClazzCall))</span><br><span class="line">    print(<span class="string">'重写__call__方法的类实例：'</span>, callable(ClazzCall()))</span><br><span class="line">    print(<span class="string">'\n----调用一下重写了__call__方法的类实例----'</span>)</span><br><span class="line">    cc = ClazzCall()</span><br><span class="line">    cc()</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----函数----</span><br><span class="line">函数对象： <span class="keyword">True</span></span><br><span class="line">匿名函数对象： <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">----普通类----</span><br><span class="line">类对象： <span class="keyword">True</span></span><br><span class="line">类实例： <span class="keyword">False</span></span><br><span class="line">实例方法对象： <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">----重写类----</span><br><span class="line">重写__call__方法的类对象： <span class="keyword">True</span></span><br><span class="line">重写__call__方法的类实例： <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">----调用一下重写了__call__方法的类实例----</span><br><span class="line">我被调用了! 参数是：(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)，&#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可调用对象就是：可以被调用的对象~</p><p>函数、方法、类都是可调用对象，而类的实例只有实现了<code>__call__</code>方法才是可调用的。</p><h2 id="装饰器使用格式介绍"><a href="#装饰器使用格式介绍" class="headerlink" title="装饰器使用格式介绍"></a>装饰器使用格式介绍</h2><p>python装饰器功能的实现需要借助一个语法糖，格式是在一个函数、方法或者类的头顶上添加<code>&#39;@&#39;+&#39;装饰器可调用对象&#39;</code>。</p><blockquote><p>注意:　　这里的<code>装饰器可调用对象</code>并不是随意一个的<code>可调用对象</code>加上去都是可以的。必须要满足这个<code>可调用对象</code>在调用时，可以用<code>可调用对象(被修饰对象)</code>这种格式执行调用才行，并且这个<code>可调用对象</code>必须要返回一个<code>可调用对象</code>，返回来的<code>可调用对象</code>将替换掉原来的对象。也就是方法头上顶个<code>&#39;@&#39;+&#39;装饰器可调用对象&#39;</code>那这个方法就等价于<code>装饰器可调用对象(方法)</code>。<br><br>还要注意的是：　这个<code>装饰器可调用对象</code>不一定就是要直接传一个对象，可以是执行一个方法，然后这个方法返回一个<code>装饰器可调用对象</code>，只要<code>@</code>后面加的是一个<code>装饰器可调用对象</code>就行了。<br><br>　　这个其实不太准确~因为@staticmethod、@classmethod…这些内置的装饰器例外（与其说这些是装饰器，还不如说是注解，用于标注方法的类型），返回的是类对象，并且不可调用~~这些特例不在讨论范围内，就姑且当这个结论是对的吧。</p></blockquote><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个作为装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'decor'</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被修饰函数</span></span><br><span class="line"><span class="meta">@decor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'fun'</span>)</span><br></pre></td></tr></table></figure><p>上面那个被修饰函数头上顶了个<code>@decor</code>后，就相当于执行了 <code>fun = decor(fun)</code>。</p><p>再举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个作为装饰器,这里的函数对象decor不满足可调用对象的格式，但是它的返回值满足。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'decor'</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被修饰函数，这里要用调用函数的返回值来获取装饰器对象。</span></span><br><span class="line"><span class="meta">@decor()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'fun'</span>)</span><br></pre></td></tr></table></figure><p>上面那个被修饰函数头上顶了个<code>@decor()</code>后，就相当于执行了 <code>fun = decor()(fun)</code>。</p><blockquote><p>还有一个要注意的是:上面说了，只要格式对了就可以作为装饰器。上面的例子中都是返回了被修饰函数对象，但如果你既不反回那个函数对象，也不在装饰器里面调用那个被修饰函数，整个装饰器都跟被修饰对象一毛钱关系都没有，这也是可以的，嗯，没看错，这也是可以的。被修饰函数头上顶了个<code>@decor</code>后，就相当于只是执行了 <code>fun = decor(fun)</code>。被修饰对象就只是装饰器对象的一个参数而已，只要<code>装饰器对象</code>（也就是<code>装饰器可调用对象</code>，太长了，下面统一叫<code>装饰器对象</code>）格式对，就不会报错，具体怎么用，随你怎么搞都可以。</p></blockquote><h2 id="构造装饰器"><a href="#构造装饰器" class="headerlink" title="构造装饰器"></a>构造装饰器</h2><p>根据生成装饰器的对象类型可分为：<code>函数装饰器</code>和<code>类装饰器</code>。 </p><p>根据生成装饰器的使用方式可分为：<code>有参装饰器</code>和<code>无参装饰器</code>。</p><blockquote><p>静态方法构造成的装饰器也可以并入<code>函数装饰器</code>，反正都是一回事。</p></blockquote><h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><h4 id="无参函数装饰器"><a href="#无参函数装饰器" class="headerlink" title="无参函数装饰器"></a>无参函数装饰器</h4><p>无参函数装饰器是最简单的装饰器了，直接看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个作为装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'decor'</span>)</span><br><span class="line"><span class="comment"># 必须要返回一个对象，这个对象将替换原来的函数对象，</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被修饰函数</span></span><br><span class="line"><span class="meta">@decor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'fun'</span>)</span><br></pre></td></tr></table></figure><p>为了验证装饰器中返回的对象将替换原来的函数对象，再写一个例子，并运行结果看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'decor_inner'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_2</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'decor_2'</span>)</span><br><span class="line">    <span class="keyword">return</span> decor_inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decor_2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_a</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'fun_a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fun_a()</span><br><span class="line">    fun_a.__name__</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是运行结果</span></span><br><span class="line"></span><br><span class="line">decor_2</span><br><span class="line">decor_inner</span><br></pre></td></tr></table></figure><p>结论： 确实是替换了原来的函数，连名字都被替换了。</p><h4 id="有参函数装饰器"><a href="#有参函数装饰器" class="headerlink" title="有参函数装饰器"></a>有参函数装饰器</h4><p>构造一个有参装饰器函数的关键是：怎么构造一个可以<code>兼容原函数参数</code>的<code>可调用对象</code>。</p><p>先看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有参的函数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor</span><span class="params">(param)</span>:</span></span><br><span class="line">    <span class="comment"># 构造了一个的可用的装饰器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器参数：'</span>, param)</span><br><span class="line">        <span class="comment"># 由于返回的就是函数本身，所以肯定可以兼容原来的参数</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回装饰器对象</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时要执行函数，才能返回一个正确的对象</span></span><br><span class="line"><span class="meta">@decor(333)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'func'</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func_1(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">装饰器参数： <span class="number">333</span></span><br><span class="line">func <span class="number">12</span></span><br></pre></td></tr></table></figure><p>上面的例子中由于直接返回了原来的函数，所以可以兼容原来函数的参数，但如果我们需要对传入函数的参数进行处理，那就需要去获取运行时传入的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 有参的函数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_2</span><span class="params">(param)</span>:</span></span><br><span class="line">    <span class="comment"># 构造了一个的可用的装饰器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器参数：'</span>, param)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造一个可兼容原函数参数的对象，只要跟原函数参数一致即可</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">new_fun</span><span class="params">(fun_param)</span>:</span></span><br><span class="line">            print(<span class="string">'运行时传入的参数：'</span>, fun_param)</span><br><span class="line">            func(fun_param + param)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_fun</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回装饰器对象</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时要执行函数，才能返回一个正确的对象</span></span><br><span class="line"><span class="meta">@decor_2(333)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'最终的参数： '</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func_2(<span class="number">12</span>)</span><br><span class="line">    print(func_2.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">装饰器参数： <span class="number">333</span></span><br><span class="line">运行时传入的参数： <span class="number">12</span></span><br><span class="line">最终的参数： <span class="number">345</span></span><br><span class="line">new_fun</span><br></pre></td></tr></table></figure><p>上面的例子虽然是实现了装饰器传参，但是装饰器一般都是用于做通用功能的，不可能每写一个函数就搞一个装饰器吧？下面就来实现一个比较通用的装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有参的函数装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_3</span><span class="params">(param)</span>:</span></span><br><span class="line">    <span class="comment"># 构造了一个的可用的装饰器对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器参数：'</span>, param)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造一个可兼容原函数参数的对象, 用这种通用的传参形式即可 *args, **kwargs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">new_fun</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">            print(<span class="string">'运行时传入的参数：'</span>, args, kwargs)</span><br><span class="line">            args = map(<span class="keyword">lambda</span> x: x + param, args)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 通用形式去调用原函数，记得加上*</span></span><br><span class="line">            func_result = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> func_result  <span class="comment"># 把执行结果返回，兼容那些需要返回结果的函数。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_fun</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回装饰器对象（同理：这里并不是一定要直接返回这装饰器对象，也可以通过调用方法的形式，只要最终返回的对象满足条件即可）</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时要执行函数，才能返回一个正确的对象</span></span><br><span class="line"><span class="meta">@decor_3(222)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_3</span><span class="params">(a)</span>:</span></span><br><span class="line">    print(<span class="string">'最终的参数： '</span>, a)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'打印返回的结果：'</span>, func_3(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">装饰器参数： <span class="number">222</span></span><br><span class="line">运行时传入的参数： (<span class="number">12</span>,) &#123;&#125;</span><br><span class="line">最终的参数：  <span class="number">234</span></span><br><span class="line">打印返回的结果： <span class="number">234</span></span><br></pre></td></tr></table></figure><p>通过把构造一个参数为<code>*args, **kwargs</code>的可调用对象，可兼容函数的输入参数类型。</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>类装饰器就是通过重写<code>__call__</code>方法，使实例可调用的特性来搞的。</p><h4 id="无参类装饰器"><a href="#无参类装饰器" class="headerlink" title="无参类装饰器"></a>无参类装饰器</h4><p>无参类装饰器是利用类生成实例时可传入参数，将函数对象作为参数，然后重写<code>__call__</code>方法，使得实例可调用，满足装饰器对象的条件实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 传入的参数可为一个func,类实例化本来就会返回一个对象，只要这个对象是满足可调用就行了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="comment"># 将传入的方法对象变成成员变量，用于调用</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写call方法，使实例可调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'c1'</span>, *args, **kwargs)</span><br><span class="line">        self._func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'c2'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">(b)</span>:</span></span><br><span class="line">    print(<span class="string">'hello '</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func_1(<span class="string">'world'</span>)</span><br><span class="line">    print(func_1.__dict__)  <span class="comment"># 这个方法对象实际上已经变成类对象了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">c1 world</span><br><span class="line">hello  world</span><br><span class="line">c2</span><br><span class="line">&#123;<span class="string">'_func'</span>: &lt;function func_1 at <span class="number">0x0000015DC0385A60</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>这里的方法对象实际上已经变成类的实例对象，当运行函数时，也就是运行实例的<code>__call__</code>方法。</p><h4 id="有参类装饰器"><a href="#有参类装饰器" class="headerlink" title="有参类装饰器"></a>有参类装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 将传入装饰器的参数作为实例的成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kw)</span>:</span></span><br><span class="line">        self.arg = args</span><br><span class="line">        self.kwarg = kw</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在call方法里构造一个可调用并且兼容原函数参数的对象即可</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        print(<span class="string">'装饰器参数：'</span>, self.arg, self.kwarg)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            f = func(*args, **kw)</span><br><span class="line">            print(<span class="string">'函数参数：'</span>, args, kw)</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo2('a', a=97)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">(b)</span>:</span></span><br><span class="line">    print(<span class="string">'执行函数：'</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func_2(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">装饰器参数： (<span class="string">'a'</span>,) &#123;<span class="string">'a'</span>: <span class="number">97</span>&#125;</span><br><span class="line">执行函数： world</span><br><span class="line">函数参数： (<span class="string">'world'</span>,) &#123;&#125;</span><br></pre></td></tr></table></figure><p>有参类装饰器是将生成实例时的参数变成成员变量，使用装饰器时，直接生成一个实例，然后在<code>__call__</code>方法里构造一个装饰器对象返回，调用实例返回的对象满足装饰器对象条件即可。</p><h3 id="装饰器链"><a href="#装饰器链" class="headerlink" title="装饰器链"></a>装饰器链</h3><p>一个被装饰器修饰后的可调用对象，只要它还是一个可调用对象，就可以继续被修饰，但要注意之前说的<code>@staticmethod、@classmethod...</code>这些装饰器修饰完之后，这个对象不是个可调用对象，比如：<code>@staticmethod</code>它返回的是<code>staticmethod</code>类对象，并且不是个可调用对象，在它外层再加装饰器会报错，虽然<code>@staticmethod</code>并没有把返回的类对象把原函数对象替换，原函数对象还是个可调用对象。如果需要给静态方法添加装饰器，只需要把<code>@staticmethod</code>放在最外层即可。</p><p>跑偏了~这里是来介绍装饰器链的，直接来个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'decor_1: 前'</span>)</span><br><span class="line">        f = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'decor_1: 后'</span>)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'decor_2: 前'</span>)</span><br><span class="line">        f = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'decor_2: 后'</span>)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decor_2</span></span><br><span class="line"><span class="meta">@decor_1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'执行原函数'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">decor_2: 前</span><br><span class="line">decor_1: 前</span><br><span class="line">执行原函数</span><br><span class="line">decor_1: 后</span><br><span class="line">decor_2: 后</span><br></pre></td></tr></table></figure><p>上面那个func函数头上顶了个多个装饰器就相当于是<code>fun = decor_2(decor_1(fun))</code>。</p><p>向上面那个例子，如果觉得多个装饰器一层一层叠着不好看，也可以用以下的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'decor_1: 前'</span>)</span><br><span class="line">        f = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'decor_1: 后'</span>)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'decor_2: 前'</span>)</span><br><span class="line">        f = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'decor_2: 后'</span>)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decor_compose</span><span class="params">(*funs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> fun <span class="keyword">in</span> reversed(funs):</span><br><span class="line">            f = fun(f)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decor_compose(decor_2, decor_1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'执行原函数'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">decor_2: 前</span><br><span class="line">decor_1: 前</span><br><span class="line">执行原函数</span><br><span class="line">decor_1: 后</span><br><span class="line">decor_2: 后</span><br></pre></td></tr></table></figure><h2 id="装饰器实践"><a href="#装饰器实践" class="headerlink" title="装饰器实践"></a>装饰器实践</h2><p>好了，既然已经介绍完装饰器，那就来实践一下吧，用装饰器实现个简单的发布订阅模型！代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notify</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个类成员字典变量，用于保存所有的订阅者函数对象和订阅的内容</span></span><br><span class="line">    all_subscriber = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(cls, title, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        通知</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 这里就只是简单的循环并运行一下所有订阅者</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> cls.all_subscriber.get(title, []):</span><br><span class="line">            item(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auto_publish</span><span class="params">(title)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        发布装饰器：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            把这个函数作为一个装饰器，用于执行完函数后通知相关订阅者。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">sub_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">                msg = func(*args, *kwargs)</span><br><span class="line">                <span class="comment"># 把原函数的返回值作为消息，通知订阅者</span></span><br><span class="line">                Notify.notify(title, msg)</span><br><span class="line">                <span class="keyword">return</span> msg</span><br><span class="line">            <span class="keyword">return</span> sub_func</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(title)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        订阅</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="comment">#  这里把订阅者要订阅的标题作为key,数组作为value,再把那个订阅者函数添加到数组里</span></span><br><span class="line">            Notify.all_subscriber.setdefault(title, []).append(func)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">sub_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">                f = func(*args, *kwargs)</span><br><span class="line">                <span class="keyword">return</span> f</span><br><span class="line">            <span class="keyword">return</span> sub_func</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Notify.auto_publish('boss')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gan</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'我干完了'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Notify.subscribe('handsome')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'帅哥一号：干啥？'</span>, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Notify.subscribe('handsome')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'帅哥二号：干啥子？'</span>, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Notify.subscribe('boss')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(<span class="string">'老板：干完了没？'</span>, msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Notify.notify(<span class="string">'handsome'</span>, <span class="string">'来玩啊！'</span>)</span><br><span class="line">    gan(<span class="string">'嗯嗯啊...'</span>)</span><br><span class="line">    Notify.notify(<span class="string">'handsome'</span>, <span class="string">'不要钱哦！'</span>)</span><br><span class="line">    gan(<span class="string">'121、121...'</span>)</span><br><span class="line">    Notify.notify(<span class="string">'empty'</span>, <span class="string">'测试'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"></span><br><span class="line">帅哥一号：干啥？ 来玩啊！</span><br><span class="line">帅哥二号：干啥子？ 来玩啊！</span><br><span class="line">嗯嗯啊...</span><br><span class="line">老板：干完了没？ 我干完了</span><br><span class="line">帅哥一号：干啥？ 不要钱哦！</span><br><span class="line">帅哥二号：干啥子？ 不要钱哦！</span><br><span class="line"><span class="number">121</span>、<span class="number">121.</span>..</span><br><span class="line">老板：干完了没？ 我干完了</span><br></pre></td></tr></table></figure><p>官网对装饰器的介绍：</p><p><a href="https://www.python.org/dev/peps/pep-0318/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0318/</a></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>收藏一份浏览器发展时间轴</title>
      <link href="/2018/06/28/%E6%B5%8F%E8%A7%88%E5%99%A8Timeline/"/>
      <url>/2018/06/28/%E6%B5%8F%E8%A7%88%E5%99%A8Timeline/</url>
      <content type="html"><![CDATA[<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h3 id="pc浏览器内核"><a href="#pc浏览器内核" class="headerlink" title="pc浏览器内核"></a>pc浏览器内核</h3><p>主要有：Trident、KHTML、 Gecko、WebKit、Presto、Chromium、Blink、EdgeHtml…</p><a id="more"></a><h3 id="移动端浏览器内核"><a href="#移动端浏览器内核" class="headerlink" title="移动端浏览器内核"></a>移动端浏览器内核</h3><p>主要有：webkit、chromium、blink、trident、u3、u4、x5…<br><br></p><h2 id="浏览器发展预览图"><a href="#浏览器发展预览图" class="headerlink" title="浏览器发展预览图"></a>浏览器发展预览图</h2><p><div style="text-align: center;"><br><a href="./Timeline_of_web_browsers.svg" target="_blank">点击此处查看大图</a><br></div><br><br><br><img src="/2018/06/28/浏览器Timeline/./Timeline_of_web_browsers.svg" alt=""></p><p>图片来源：</p><p><a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Timeline_of_web_browsers</a></p>]]></content>
      
      <categories>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL介绍</title>
      <link href="/2018/06/24/SQL%E5%88%86%E7%B1%BB/"/>
      <url>/2018/06/24/SQL%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　SQL是英文Structured Query Language的缩写，意思为结构化查询语言。SQL语言的主要功能就是同各种数据库建立联系，进行沟通。按照ANSI(美国国家标准协会)的规定，SQL被作为关系型数据库管理系统的标准语言。</p><a id="more"></a><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><p>　　在1970年代初，由IBM公司San Jose,California研究实验室的埃德加·科德发表将数据组成表格的应用原则（Codd’s Relational Algebra）。</p><p>　　1974年，San Jose,California研究实验室的D.D.Chamberlin和R.F. Boyce对Codd’s Relational Algebra在研制关系数据库管理系统System R中，研制出一套规范语言-SEQUEL（Structured English QUEry Language），并在1976年11月的IBM Journal of R&amp;D上公布新版本的SQL（叫SEQUEL/2）。</p><p>　　1980年改名为SQL。</p><p>　　1979年ORACLE公司首先提供商用的SQL，IBM公司在DB2和SQL/DS数据库系统中也实现了SQL。</p><p>　　1986年10月，美国ANSI采用SQL作为关系数据库管理系统的标准语言（ANSI X3. 135-1986），后为国际标准化组织（ISO）采纳为国际标准。</p><p>　　1989年，美国ANSI采纳在ANSI X3.135-1989报告中定义的关系数据库管理系统的SQL标准语言，称为ANSI SQL 89，该标准替代ANSI X3.135-1986版本。</p><h2 id="SQL语句结构分类"><a href="#SQL语句结构分类" class="headerlink" title="SQL语句结构分类"></a>SQL语句结构分类</h2><h4 id="一、数据查询语言（DQL-Data-Query-Language）："><a href="#一、数据查询语言（DQL-Data-Query-Language）：" class="headerlink" title="一、数据查询语言（DQL:Data Query Language）："></a>一、数据查询语言（DQL:Data Query Language）：</h4><blockquote><p>DQL语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。</p></blockquote><h4 id="二、-数据操作语言（DML：Data-Manipulation-Language）："><a href="#二、-数据操作语言（DML：Data-Manipulation-Language）：" class="headerlink" title="二、 数据操作语言（DML：Data Manipulation Language）："></a>二、 数据操作语言（DML：Data Manipulation Language）：</h4><blockquote><p>DML包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。</p></blockquote><h4 id="三、-事务处理语言（TCL：Transaction-Control-Language）："><a href="#三、-事务处理语言（TCL：Transaction-Control-Language）：" class="headerlink" title="三、 事务处理语言（TCL：Transaction Control Language）："></a>三、 事务处理语言（TCL：Transaction Control Language）：</h4><blockquote><p>TCL语句能确保被DML语句影响的表的所有行及时得以更新。TCL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。</p></blockquote><h4 id="四、-数据控制语言（DCL：Data-Control-Language）："><a href="#四、-数据控制语言（DCL：Data-Control-Language）：" class="headerlink" title="四、 数据控制语言（DCL：Data Control Language）："></a>四、 数据控制语言（DCL：Data Control Language）：</h4><blockquote><p>DCL的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。</p></blockquote><h4 id="五、-数据定义语言（DDL：Data-Definition-Language）："><a href="#五、-数据定义语言（DDL：Data-Definition-Language）：" class="headerlink" title="五、 数据定义语言（DDL：Data Definition Language）："></a>五、 数据定义语言（DDL：Data Definition Language）：</h4><blockquote><p>DDL的语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。</p></blockquote><h2 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h2><h3 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h3><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等（CREATE TABLE/VIEW/INDEX/SYN/CLUSTER）：</p><h4 id="对数据库的操作"><a href="#对数据库的操作" class="headerlink" title="对数据库的操作"></a>对数据库的操作</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建:"></a>创建:</h5><pre><code>create database &lt;数据库名&gt;；创建数据库create database &lt;数据库名&gt; character set utf8; 创建数据库并设置编码为utf-8；create database &lt;数据库名&gt; character set gbk collate gbk_chinese_ci  创建数据库，并设置编码为gbk，增加校验</code></pre><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><pre><code>drop database &lt;数据库名&gt;; 删除数据库</code></pre><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><pre><code>alter database &lt;数据库名&gt; character set utf8;  修改数据库编码为utf-8；</code></pre><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><pre><code>show databases; 查看所有数据库show create database &lt;数据库名&gt;; 查看创建数据库的定义信息</code></pre><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><pre><code>select database(); 查看当前使用数据库use &lt;数据库名&gt;; 使用数据库</code></pre><h4 id="对数据表操作："><a href="#对数据表操作：" class="headerlink" title="对数据表操作："></a>对数据表操作：</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><pre><code>CREATE TABLE &lt;表名&gt; (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `remark` varchar(255) DEFAULT NULL,  `appid` int(11) DEFAULT NULL,  `weight` float DEFAULT &apos;1&apos;,  PRIMARY KEY (`id`),  UNIQUE KEY `appid` (`appid`,`name`) USING BTREE,  CONSTRAINT `appid` FOREIGN KEY (`appid`) REFERENCES &lt;数据库名&gt; (&lt;要关联的列明&gt;) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8</code></pre><h5 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h5><pre><code>show tables; 当前数据库中的所有表desc &lt;表名&gt;; 查看表的字段信息show create table &lt;表名&gt;;  查看表格的创建细节</code></pre><h5 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h5><pre><code>alter table &lt;表名&gt; add &lt;列名&gt; &lt;数据类型&gt;; 在表中增加一列；alter table &lt;表名&gt; modify &lt;列名&gt; varchar(60); 修改列的数据类型 ;alter table &lt;表名&gt; change &lt;旧列名&gt; &lt;新列名&gt; varchar(100); 修改列名，带上数据类型；alter table &lt;表名&gt; drop &lt;列名&gt;; 删除列；alter table &lt;表名&gt; character set utf8; 修改表的字符集为utf-8；</code></pre><h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><pre><code>rename table &lt;旧的表名&gt; to &lt;新的表名&gt;; 修改表名；drop table &lt;表名&gt;; 删除表(结构和数据)；truncate table &lt;表名&gt;;清空表记录delete from &lt;表名&gt; [where &lt;删除条件&gt;];删除表记录可根据条件删除部分</code></pre><h3 id="数据控制语言DCL"><a href="#数据控制语言DCL" class="headerlink" title="数据控制语言DCL"></a>数据控制语言DCL</h3><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。</p><p>在MySQL中，不仅可以指定谁可以连接到数据库服务器，还可以指定用户连接的主机。因此，MySQL中的用户帐号由用户名，以及使用@字符分隔的主机名组成。</p><p>例如，如果admin用户从localhost主机连接到MySQL数据库服务器，则用户帐户是书写形式是：admin@localhost，其中@符号是一个固定的分隔符。</p><p>admin用户只能从本地主机(localhost)连接到MySQL数据库服务器，而不是其它远程主机。</p><blockquote><p>注意：如要限制admin用户只能从192.168.10.12主机登录，那么可以书写为：<a href="mailto:`admin@192.168.10.12" target="_blank" rel="noopener">`admin@192.168.10.12</a><code>，如果想要允许从任意主机登录，那么可以书写为：</code>admin@%`；MySQL将用户帐户授权存储在mysql数据库的user表中。</p></blockquote><h4 id="create-创建用户"><a href="#create-创建用户" class="headerlink" title="create 创建用户"></a>create 创建用户</h4><pre><code>create user 用户名@地址 identified by 密码;</code></pre><blockquote><p>其中使用的IP地址，可以设置为localhost(代表本机)或者’%’（代表允许所有IP地址登录）</p></blockquote><h4 id="grant-给用户授权"><a href="#grant-给用户授权" class="headerlink" title="grant 给用户授权"></a>grant 给用户授权</h4><pre><code> GRANT SELECT,INSERT ON 数据库名.* TO 用户名@IP地址 [IDENTIFIED BY 密码];给用户添加对其中一个数据库所有表SELECT和INSERT的权限grant all [privileges] on 数据库名 to 用户名@IP地址给用户添加对某个数据库所有的操作权限，关键字 “privileges” 可以省略grant all on . to 用户名@IP地址给某个用户添加对所有数据库的权限FLUSH PRIVILEGES;刷新权限</code></pre><h4 id="revoke-撤销授权"><a href="#revoke-撤销授权" class="headerlink" title="revoke 撤销授权"></a>revoke 撤销授权</h4><pre><code>REVOKE INSERT ON 数据库.* FROM 用户名@IP地址;取消用户对其中一个数据库所有表INSERT的权限revoke all on . from 用户名@IP地址;取消用户对所有数据库的操作FLUSH PRIVILEGES;刷新权限</code></pre><blockquote><p>注意：grant, revoke 用户权限后，该用户只有重新连接 MySQL数据库，权限才能生效。mysql不同版本直接略有差异…</p></blockquote><h4 id="ROLLBACK-事物回滚"><a href="#ROLLBACK-事物回滚" class="headerlink" title="ROLLBACK 事物回滚"></a>ROLLBACK 事物回滚</h4><pre><code>标识事务的开始：    start transaction使用ROLLBACK 命令用来回退（撤销）：    start transaction;    delete from 表名;    ...(各种修改删除操作)    rollback;</code></pre><blockquote><p>ROLLBACK 只能在一个事务处理内使用（在执行一条 START TRANSACTION 命令之后）。</p></blockquote><h4 id="COMMIT提交事物"><a href="#COMMIT提交事物" class="headerlink" title="COMMIT提交事物"></a>COMMIT提交事物</h4><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用 COMMIT 语句，如下所示：</p><pre><code>start transaction;delete from 表名 where id = 123;delete from 表名 where id = 321;commit;</code></pre><p>提交数据有三种类型：显式提交、隐式提交及自动提交。</p><ol><li><p>显式提交</p><p> 用COMMIT命令直接完成的提交为显式提交。</p></li><li><p>隐式提交</p><p> 用SQL命令间接完成的提交为隐式提交。这些命令有：ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p></li><li><p>自动提交</p><p> 若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交。命令为：SET AUTOCOMMIT ON；</p></li></ol><h3 id="数据操作语言DML"><a href="#数据操作语言DML" class="headerlink" title="数据操作语言DML"></a>数据操作语言DML</h3><p>DML主要有三种形式：</p><ol><li><p>插入：INSERT</p><p> insert into 表名(…) values(…);</p></li><li><p>更新：UPDATE</p><p> update 表名 set 列名 = 更新内容 [where 条件];</p></li><li><p>删除：DELETE</p><p> delete from 表名[where 条件];</p></li></ol><blockquote><p>注意： 在mysql中，字符串类型和日期类型都要用单引号括起来。</p></blockquote><h3 id="数据查询语言DQL"><a href="#数据查询语言DQL" class="headerlink" title="数据查询语言DQL"></a>数据查询语言DQL</h3><p>数据查询语言DQL由SELECT子句，FROM子句，WHERE子句组成：</p><pre><code>SELECT &lt;字段名表&gt;FROM &lt;表或视图名&gt;WHERE &lt;查询条件&gt;</code></pre><p>数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p><p>模糊查询 like    通配符： _任意一个字母   % 任意个字母。</p><h4 id="无条件单表查询"><a href="#无条件单表查询" class="headerlink" title="无条件单表查询"></a>无条件单表查询</h4><ol><li><p>查询表中所有列 </p><p> Select * from emp;</p></li><li><p>查询表中指定列 </p><p> 可以更改列的顺序</p><pre><code>Select ename,eno from emp; Select eno,ename from emp; </code></pre></li></ol><ol start="3"><li><p>算术运算符 </p><p> Select 子句中支持加减乘除和函数 </p><p> 查看员工年薪</p><pre><code>Select ename,empno,sal*12+comm from emp; </code></pre><p> 员工转正后，月薪上调20%， 请查询出所有员工转正的月薪；转正日期为入职后的6个月 </p><pre><code>select ENAME ‘员工姓名’ , SAL ‘实习工资’ , hiredate ‘入职日期’, hiredate+interval 6 month ‘转正日期’, sal*1.2 ‘转正工资’ from emp; </code></pre><p> 员工试用期6个月，转正后月薪上调20%，请查询所有员工工作第一年的年薪所得（不考虑奖金部分，年薪的试用期6个月的月薪+转正后的6个月的月薪） </p><pre><code>select ENAME ‘员工姓名’ , SAL ‘实习工资’ , hiredate ‘入职日期’, hiredate+interval 6 month ‘转正日期’, sal*6+sal*1.2*6 ‘年薪’ from emp; 或者 select ename,sal,DATE_ADD(hiredate,INTERVAL 6 MONTH) as newdate from emp;</code></pre></li><li><p>null </p><p> 任何值与null计算结果都为null<br> 通过ifnull 将 null 置为0 </p><pre><code>select ename,sal * 12+ifnull(comm,0) from emp;</code></pre></li><li><p>别名 </p><p> Select 列 ‘列名’ from emp; </p><p> Select 列 as ‘列名’ from emp; </p><p> 员工试用期6个月，转正后月薪上调20%，请查询出所有员工工作第一年的所有收入，需要考虑奖金部分,要求显示列标题为员工姓名，工资收入， 奖金收入，总收入 </p><pre><code>select ENAME ‘员工姓名’ , sal*6+sal*1.2*6 ‘工资收入’, ifnull(comm, 0) ‘奖金收入’ , sal*6+sal*1.2*6+ifnull(comm, 0) ‘年薪’ from emp;</code></pre></li><li><p>连接字符串 </p><p> Oracle 使用||进行字符串连接 </p><p> Sql server 使用+进行字符串连接 </p><p> Mysql 使用cancat()函数进行字符串连接 </p><pre><code>select concat(ename,‘的岗位是’,job) ‘员工岗位’ from emp;</code></pre></li><li><p>消除重复行</p><p> select distinct job from emp;</p></li></ol><h4 id="有条件单表查询"><a href="#有条件单表查询" class="headerlink" title="有条件单表查询"></a>有条件单表查询</h4><p>1． Where </p><p>关系运算符（&lt; &lt;= &gt; &gt;= &lt;&gt; != = ） 可以对数值型 字符型 日期型 直接进行运算 </p><pre><code>select empno,ename,deptno from emp where ename&gt;’王’; </code></pre><p>特殊运算符（between and in like is null） </p><pre><code>between 上限 and 下限 结果集操作包含上限和下限对应的行 like 模糊查询 %零个或者多个字符_表示有且仅有一个字符可以通过escape标示符实现对_ % 本身这两个字符的查找 不区分大小写select empno,ename,deptno from emp where empno between &apos;00002&apos; and &apos;00003&apos;;select *  from emp where comm in(500,800);select empno,ename,deptno from emp where empno in(&apos;00002&apos;,&apos;00003&apos; );select *  from emp where ename like &apos;王%&apos;;select *  from emp where hiredate like &apos;_____03%&apos;;select *  from emp where ename like &apos;%/_%&apos; escape &apos;/&apos;;</code></pre><p>逻辑运算符（ and or not） </p><p>优先级: not and or</p><p>数量限制</p><pre><code>Sql server top Oracle renum Mysql limit </code></pre><blockquote><p>Limit 0,5 0代表起始行 5代表起始行开始连续的行的个数<br>limit (pagesize-1)*pizenum,pizenum</p></blockquote><p>2．Order by</p><p>默认为升序 asc </p><p>降序序显式声明为desc</p><pre><code>select * from emp order by deptno desc; select ename,job from emp order by deptno asc;</code></pre><p>多列排序</p><pre><code>select * from emp order by deptno asc,sal desc; select ename,job from emp order by 2 asc;</code></pre><p>mysql中用命令行复制表结构的方法主要有一下几种:</p><p>1.只复制表结构到新表 </p><pre><code>CREATE TABLE 新表 SELECT * FROM 旧表 WHERE id&gt;2 ; 或 CREATE TABLE 新表 LIKE 旧表 ; </code></pre><blockquote><p>注意:上面两种方式，前一种方式是不会复制主键类型和自增方式，而后一种方式是把旧表的所有字段类型都复制到新表。</p></blockquote><p>2.复制表结构及数据到新表 </p><pre><code>CREATE TABLE 新表 SELECT * FROM 旧表</code></pre><p>3.复制旧表的数据到新表(假设两个表结构一样) </p><pre><code>INSERT INTO 新表 SELECT * FROM 旧表</code></pre><p>4.复制旧表的数据到新表(假设两个表结构不一样) </p><pre><code>INSERT INTO 新表(字段1,字段2,…….) SELECT 字段1,字段2,…… FROM 旧表</code></pre><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><ol><li>交叉连接</li></ol><p>　　不使用任何条件匹配,查询结果为笛卡尔乘积（就是两个集合中的每一个成员，都与对方集合中的任意一个成员有关联）。示例：</p><pre><code>select a.*,b.* from a,b;</code></pre><ol start="2"><li>内连接</li></ol><p>　　查询结果返回两张表中相匹配的行，内连接分为隐式连接和显示连接两种，示例：</p><pre><code>显示：select * froma [inner] join bon a.id = b.id;隐式：select a.*, b.*from a, bwhere a.id = b.id;</code></pre><ol start="3"><li>外连接</li></ol><p>左外连：</p><p>会显示左边表内所有的值，不论在右边表内匹不匹配，匹配不到的右边表中的数据为NULL。示例：</p><pre><code>select a.*, b.* from a left join bon a.id = b.id;</code></pre><p>右外连：</p><p>会显示右边表内所有的值，不论在左边表内匹不匹配，匹配不到的左边表中的数据为NULL。示例：</p><pre><code>select a.*, b.* from a right join bon a.id = b.id;</code></pre><ol start="4"><li>子查询</li></ol><p>子查询是将一个查询语句嵌套在另一个查询语句中。内层查询语句的查询结果，可以为外层查询语句提供查询条件。示例：</p><pre><code>select * from awhere id in (select id from b where age&lt;8);</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>字符函数</strong></p><p>大小写处理 </p><pre><code>LOWER(str) UPPER(str) SELECT LOWER(ename) from emp; SELECT UPPER(ENAME) from emp;</code></pre><p>字符处理函数 </p><pre><code>CONCAT(str1,str2,…) SUBSTR(str,pos,len) LENGTH(str)SELECT CONCAT(ename,’ 的薪水是 ‘,sal) 薪水 FROM emp; SELECT SUBSTR(ename,1,1) 姓氏 FROM emp; SELECT SUBSTR(ename,2) 名字 FROM emp; SELECT SUBSTR(ename,-1,1) 名字 FROM emp;SELECT ename,LENGTH(ename) 名字存储字节长度 FROM emp; SELECT ename,CHAR_LENGTH(ename) 名字字符长度 FROM emp;</code></pre><p>字符处理函数 </p><p>　　INSTR(str,substr) ：填补</p><p>　　LPAD(str,len,padstr) ：用字符串 padstr对 str进行左边填补直至它的长度达到 len个字符长度，然后返回 str。如果 str的长度长于 len’，那么它将被截除到 len个字符。 </p><p>　　RPAD(str,len,padstr) ：用字符串 padstr对 str进行右边填补直至它的长度达到 len个字符长度，然后返回 str。如果 str的长度长于 len’，那么它将被截除到 len个字符。 </p><p>　　TRIM([remstr FROM] str) ：修剪，去掉字符串首尾特点的字符，默认为空格。</p><pre><code>SELECT * from dept; SELECT loc,INSTR(LOC,&apos;楼&apos;) FROM dept; SELECT loc,LPAD(loc,10,&apos;#&apos;) FROM dept; SELECT loc,RPAD(loc,2,&apos;#&apos;) FROM dept; SELECT loc,REPLACE(loc,&apos;楼&apos;,&apos;栋&apos;) FROM dept SELECT TRIM(&apos; 你好 &apos;),TRIM(&apos;s&apos; from &apos;sssdsssddss&apos;) FROM DUAL;</code></pre><p>查询姓名包含大写或小写字母a的员工姓名:</p><pre><code>select ename,CHAR_LENGTH(ename) from emp where instr(upper(ename),&apos;A&apos;)&gt;0;</code></pre><p><strong>数值函数</strong></p><pre><code>SELECT FLOOR(RAND()*100) FROM DUAL; SELECT sal,CONCAT(&apos;$&apos;,ROUND(sal,2))from emp;</code></pre><blockquote><p>ROUND：Round（number，[decimals]）<br><br>number : 待做四舍五入处理的数值 <br><br>decimals : 指明需保留小数点后面的位数。可选项，忽略它则保留0位小数，精确到个位；为负数，表示为小数点左边四舍五入处理。</p></blockquote><p><strong>日期函数</strong></p><p>时间相加 </p><pre><code>SELECT DATE_ADD(CURDATE(), INTERVAL 31 DAY) SELECT ADDDATE(CURDATE(), INTERVAL 31 DAY)</code></pre><p>时间查询 </p><pre><code>SELECT DATE(‘2003-12-31 01:02:03’) SELECT DATEDIFF(‘1997-11-30’,’1997-12-31’) SELECT SUBDATE(CURDATE(), INTERVAL 3 DAY) SELECT INTERVAL 1 DAY + ‘1997-12-31’</code></pre><p>日期格式调整</p><pre><code>SELECT DATE_FORMAT(CURDATE(),’%Y年%M月%D日’) SELECT DAYOFMONTH(NOW()),DAYOFWEEK(NOW())</code></pre><p>取出日期 </p><pre><code>SELECT DATE(NOW())</code></pre><blockquote><p>注意：<br><br>查询语句书写顺序： select  -  from  -  where  -  group by  –  having  –  ordre by –  limit;<br><br>查询语句执行顺序： from -  where – group by – having – select  – order by – lilmit;</p></blockquote><p>…</p>]]></content>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机内存</title>
      <link href="/2018/06/23/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/"/>
      <url>/2018/06/23/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>在讨论JVM内存区域分析之前，先来看一下Java程序具体执行的过程：</p><p><img src="/2018/06/23/java虚拟机内存/1.png" alt="Java程序执行过程"></p><blockquote><p>Java 程序的执行过程：</p><p>Java 源代码文件（.Java文件）-&gt; Java Compiler（Java编译器）-&gt;Java 字节码文件（.class文件）-&gt;类加载器（Class Loader）-&gt;Runtime Data Area（运行时数据）-&gt; Execution Engine（执行引擎）。 </p></blockquote><a id="more"></a><p>我们今天就来分析一下Java程序执行过程的 Runtime Data Area（运行时数据）这一块。</p><h3 id="那么运行时数据区包括哪几部分呢？"><a href="#那么运行时数据区包括哪几部分呢？" class="headerlink" title="那么运行时数据区包括哪几部分呢？"></a>那么运行时数据区包括哪几部分呢？</h3><ul><li>程序计数器（Program Counter Register）</li><li>Java虚拟机栈（VM Stack）</li><li>本地方法栈（Native Method Stack）</li><li>方法区（method area）</li><li>堆（heap）</li></ul><h2 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h2><p>　　用来指示程序执行哪一条指令，这跟汇编语言的程序计数器的功能在逻辑上是一样的。JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令地址，如果线程执行的是native方法，则程序计数器中的值undefined。</p><p>　　每个线程都有自己独立的程序计数器。为什么呢？</p><p>　　因为多线程下，一个CPU内核只会执行一条线程中的指令，因此为了使每个线程在线程切换之后能够恢复到切换之前的程序执行的位置，所以每个线程都有自己独立的程序计数器。</p><h2 id="二、Java虚拟机栈"><a href="#二、Java虚拟机栈" class="headerlink" title="二、Java虚拟机栈"></a>二、Java虚拟机栈</h2><p>　　Java虚拟机栈中存放的是一个个栈帧，当程序执行一个方法时，就会创建一个栈帧并压入栈中，当方法执行完毕之后，便会将栈帧移除栈。</p><p>　　我们所说的“栈”是指Java虚拟机栈，一个栈帧中包括：局部变量表、操作数栈、动态连接、方法返回地址、附加信息。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>　　局部变量表主要是存储方法中的局部变量，包括方法中局部变量的信息和方法的参数。如：各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址），其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p><p>　　局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。</p><blockquote><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li><li>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul></blockquote><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>　　虚拟机把操作数栈作为它的工作区，程序中的所有计算过程都是在借助于操作数栈来完成的，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>　　每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用（指向运行时常量池：在方法执行的过程中有可能需要用到类中的常量），持有这个引用是为了支持方法调用过程中的动态连接。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>　　当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>　　虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</p><h2 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h2><p>　　本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><blockquote><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p></blockquote><h2 id="四、堆（heap）"><a href="#四、堆（heap）" class="headerlink" title="四、堆（heap）"></a>四、堆（heap）</h2><p>　　在C语言中，程序员可以通过malloc函数和free函数在堆上申请和释放空间。那么在Java中是怎么样的呢？Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的），几乎所有的对象实例都在这里分配内存。在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。</p><p>　　另外，堆是被所有线程共享的，在JVM中只有一个堆。</p><h2 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h2><p>　　方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等。</p><p>　　运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><blockquote><p>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。</p></blockquote><p>原文地址：<a href="https://www.jianshu.com/p/4f32f371215d" target="_blank" rel="noopener">https://www.jianshu.com/p/4f32f371215d</a></p>]]></content>
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python对象的真与假</title>
      <link href="/2018/06/21/python%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9C%9F%E4%B8%8E%E5%81%87/"/>
      <url>/2018/06/21/python%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9C%9F%E4%B8%8E%E5%81%87/</url>
      <content type="html"><![CDATA[<h2 id="python中的真假值对照表"><a href="#python中的真假值对照表" class="headerlink" title="python中的真假值对照表"></a>python中的真假值对照表</h2><table><thead><tr><th>类型</th><th style="text-align:center">False</th><th style="text-align:center">True</th></tr></thead><tbody><tr><td>布尔</td><td style="text-align:center">False</td><td style="text-align:center">True</td></tr><tr><td>数值</td><td style="text-align:center">0,   0.0</td><td style="text-align:center">非零的数值</td></tr><tr><td>字符串</td><td style="text-align:center">‘’(空字符串)</td><td style="text-align:center">非空字符串</td></tr><tr><td>容器</td><td style="text-align:center">[],  (),  {},  set()</td><td style="text-align:center">至少有一个元素的容器对象</td></tr><tr><td>None</td><td style="text-align:center">None和某些非None对象</td><td style="text-align:center">大部分非None对象</td></tr></tbody></table><h2 id="非None对象的真假值判断"><a href="#非None对象的真假值判断" class="headerlink" title="非None对象的真假值判断"></a>非None对象的真假值判断</h2><h3 id="bool类介绍"><a href="#bool类介绍" class="headerlink" title="bool类介绍"></a>bool类介绍</h3><p>Python最初是用int来做真假逻辑判断的。在Python 2.3版本中开始引入bool类型（True与False）。</p><p>bool类是int的子类，所以True和False也就相当于1和0。</p><p>下面看一下bool类：</p><pre><code>class bool(int):    &quot;&quot;&quot;    bool(x) -&gt; bool    Returns True when the argument x is true, False otherwise.    The builtins True and False are the only two instances of the class bool.    The class bool is a subclass of the class int, and cannot be subclassed.    &quot;&quot;&quot;</code></pre><blockquote><p>注释翻译：当参数x为真时，返回为真，否则将返回False。真的和假的是类bool的两个实例。类bool是类int的子类，不能被子类化。</p></blockquote><p>打印一下发现，确实是这样的！<br> <img src="/2018/06/21/python对象的真与假/1.png" alt=""></p><h3 id="对象真假值分析"><a href="#对象真假值分析" class="headerlink" title="对象真假值分析"></a>对象真假值分析</h3><p>在做真假逻辑判断时，我们通过if 来判断这个对象的真假时，其实是通过bool()来进行判断的，也就是if a： 相当于if bool(a): ，而if bool(a): 其实是通过对象的<code>__bool__()</code>（python2 中是<code>__nonzero__()</code>）函数或者<code>__len__()</code>的返回值来决定的，下面来看一下<code>__bool__()</code>和<code>__nonzero__()</code>函数的官方文档介绍：</p><ul><li><code>object.__bool__(self)</code></li></ul><blockquote><p>Called to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither<code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p></blockquote><ul><li><code>object.__nonzero__(self)</code></li></ul><blockquote><p>Called to implement truth value testing and the built-in operation bool(); should return False or True, or their integer equivalents 0 or 1. When this method is not defined, <code>__len__()</code>is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code> nor <code>__nonzero__()</code>, all its instances are considered true.</p></blockquote><blockquote><p>有道翻译：要求实现真值测试和内置的bool（）;应该返回False或True。当这个方法没有被定义时，如果它被定义了，len（）就会被调用，如果它的结果是非零的，那么这个对象就被认为是正确的。如果一个类既没有定义len（）也不定义bool（），那么它的所有实例都被认为是正确的。</p></blockquote><p>写一个类重写<code>__bool__()</code>和<code>__len__()</code>试一下：</p><p>先看一下正常的：</p><p><img src="/2018/06/21/python对象的真与假/2.png" alt=""></p><p>重写<code>__bool__()</code>返回False:</p><p><img src="/2018/06/21/python对象的真与假/3.png" alt=""></p><p>重写<code>__bool__()</code>返回True:</p><p><img src="/2018/06/21/python对象的真与假/4.png" alt=""></p><p>重写<code>__len__()</code>返回0:</p><p><img src="/2018/06/21/python对象的真与假/5.png" alt=""></p><p>重写<code>__len__()</code>返回大于0:</p><p><img src="/2018/06/21/python对象的真与假/6.png" alt=""></p><p>重写<code>__len__()</code>返回大于0，<code>__bool__()</code>返回False:</p><p><img src="/2018/06/21/python对象的真与假/7.png" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>__len__()</code>函数对非None对象的真假判断起辅助作用，<code>__bool__()</code>函数起决定作用。</p><p>最后再python官方文档对<code>object.__bool__</code>的介绍：</p><p><a href="https://docs.python.org/3.5/reference/datamodel.html?highlight=__bool__#object.__bool__" target="_blank" rel="noopener">https://docs.python.org/3.5/reference/datamodel.html?highlight=<strong>bool</strong>#object.<strong>bool</strong></a></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python之禅</title>
      <link href="/2018/06/11/python%E4%B9%8B%E7%A6%85/"/>
      <url>/2018/06/11/python%E4%B9%8B%E7%A6%85/</url>
      <content type="html"><![CDATA[<h3 id="《python之禅》及翻译"><a href="#《python之禅》及翻译" class="headerlink" title="《python之禅》及翻译"></a>《python之禅》及翻译</h3><p>在Python shell中输入<code>import this</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&apos;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&apos;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&apos;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&apos;s do more of those!</span><br></pre></td></tr></table></figure><p>中文翻译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">《python之禅》，Tim Peters著</span><br><span class="line"></span><br><span class="line">优美胜于丑陋</span><br><span class="line">明了胜于晦涩</span><br><span class="line">简洁胜于复杂 </span><br><span class="line">复杂胜于凌乱</span><br><span class="line">扁平胜于嵌套 </span><br><span class="line">间隔胜于紧凑</span><br><span class="line">可读性很重要 </span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则 </span><br><span class="line">不要包容所有错误，除非你确定需要这样做 </span><br><span class="line">当存在多种可能，不要尝试去猜测 </span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案</span><br><span class="line">虽然这并不容易，因为你不是 Python 之父</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做</span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用</span><br></pre></td></tr></table></figure><p>再在Python shell中输入<code>this.__file__</code>找到this.py文件的路径:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>this.__file__</span><br><span class="line"><span class="string">'e:\\python\\Lib\\this.py'</span></span><br></pre></td></tr></table></figure><p>根据路径打开this.py文件，显示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="string">"""Gur Mra bs Clguba, ol Gvz Crgref</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Ornhgvshy vf orggre guna htyl.</span></span><br><span class="line"><span class="string">Rkcyvpvg vf orggre guna vzcyvpvg.</span></span><br><span class="line"><span class="string">Fvzcyr vf orggre guna pbzcyrk.</span></span><br><span class="line"><span class="string">Pbzcyrk vf orggre guna pbzcyvpngrq.</span></span><br><span class="line"><span class="string">Syng vf orggre guna arfgrq.</span></span><br><span class="line"><span class="string">Fcnefr vf orggre guna qrafr.</span></span><br><span class="line"><span class="string">Ernqnovyvgl pbhagf.</span></span><br><span class="line"><span class="string">Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.</span></span><br><span class="line"><span class="string">Nygubhtu cenpgvpnyvgl orngf chevgl.</span></span><br><span class="line"><span class="string">Reebef fubhyq arire cnff fvyragyl.</span></span><br><span class="line"><span class="string">Hayrff rkcyvpvgyl fvyraprq.</span></span><br><span class="line"><span class="string">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span></span><br><span class="line"><span class="string">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span></span><br><span class="line"><span class="string">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.</span></span><br><span class="line"><span class="string">Abj vf orggre guna arire.</span></span><br><span class="line"><span class="string">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span></span><br><span class="line"><span class="string">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        d[chr(i+c)] = chr((i+<span class="number">13</span>) % <span class="number">26</span> + c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br></pre></td></tr></table></figure><p>嗯…</p><h3 id="this-py代码分析"><a href="#this-py代码分析" class="headerlink" title="this.py代码分析"></a>this.py代码分析</h3><p>来分析一些这段代码：</p><ul><li>先是声明了一个字符串变量<code>s</code>，字符串是乱的~，从格式上看跟输入<code>import this</code>显示的一样，感觉上就是把字符串里的每个字符调换了而已；</li><li>然后是声明了一个空字典<code>d</code>，然后写了两层循环对字典进行赋值，chr（）函数是输入一个整数（0，255）返回其对应的ascii值,65对应的ascii码值是’A’,97对应的是’a’,97+26-1=122对应的值是’z’；</li><li>最后是遍历一开始声明的<code>s</code>，把<code>s</code>中的每个字符作为key去取字典<code>d</code>中的value生成一个新的列表，再把这个列表join空字符串””生成一个新的字符串，打印新的字符串，这个新的字符串就是我们输入<code>import this</code>显示出来的《python之禅》。</li></ul><p>嗯，基本上已经知道是怎么实现的了！</p><p>然后打印一下生成后的字典<code>d</code>看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;A&apos;: &apos;N&apos;, &apos;C&apos;: &apos;P&apos;, &apos;B&apos;: &apos;O&apos;, &apos;E&apos;: &apos;R&apos;,</span><br><span class="line"> &apos;D&apos;: &apos;Q&apos;, &apos;G&apos;: &apos;T&apos;, &apos;F&apos;: &apos;S&apos;, &apos;I&apos;: &apos;V&apos;,</span><br><span class="line"> &apos;H&apos;: &apos;U&apos;, &apos;K&apos;: &apos;X&apos;, &apos;J&apos;: &apos;W&apos;, &apos;M&apos;: &apos;Z&apos;,</span><br><span class="line"> &apos;L&apos;: &apos;Y&apos;, &apos;O&apos;: &apos;B&apos;, &apos;N&apos;: &apos;A&apos;, &apos;Q&apos;: &apos;D&apos;,</span><br><span class="line"> &apos;P&apos;: &apos;C&apos;, &apos;S&apos;: &apos;F&apos;, &apos;R&apos;: &apos;E&apos;, &apos;U&apos;: &apos;H&apos;,</span><br><span class="line"> &apos;T&apos;: &apos;G&apos;, &apos;W&apos;: &apos;J&apos;, &apos;V&apos;: &apos;I&apos;, &apos;Y&apos;: &apos;L&apos;,</span><br><span class="line"> &apos;X&apos;: &apos;K&apos;, &apos;Z&apos;: &apos;M&apos;, &apos;a&apos;: &apos;n&apos;, &apos;c&apos;: &apos;p&apos;,</span><br><span class="line"> &apos;b&apos;: &apos;o&apos;, &apos;e&apos;: &apos;r&apos;, &apos;d&apos;: &apos;q&apos;, &apos;g&apos;: &apos;t&apos;,</span><br><span class="line"> &apos;f&apos;: &apos;s&apos;, &apos;i&apos;: &apos;v&apos;, &apos;h&apos;: &apos;u&apos;, &apos;k&apos;: &apos;x&apos;,</span><br><span class="line"> &apos;j&apos;: &apos;w&apos;, &apos;m&apos;: &apos;z&apos;, &apos;l&apos;: &apos;y&apos;, &apos;o&apos;: &apos;b&apos;,</span><br><span class="line"> &apos;n&apos;: &apos;a&apos;, &apos;q&apos;: &apos;d&apos;, &apos;p&apos;: &apos;c&apos;, &apos;s&apos;: &apos;f&apos;,</span><br><span class="line"> &apos;r&apos;: &apos;e&apos;, &apos;u&apos;: &apos;h&apos;, &apos;t&apos;: &apos;g&apos;, &apos;w&apos;: &apos;j&apos;,</span><br><span class="line"> &apos;v&apos;: &apos;i&apos;, &apos;y&apos;: &apos;l&apos;, &apos;x&apos;: &apos;k&apos;, &apos;z&apos;: &apos;m&apos;&#125;</span><br></pre></td></tr></table></figure><p>确实是就一个普通的字典。</p><h3 id="this-py模块s字符串生成"><a href="#this-py模块s字符串生成" class="headerlink" title="this.py模块s字符串生成"></a>this.py模块s字符串生成</h3><p>经过分析：python之禅是由字符串<code>s</code>通过字典<code>d</code>的（key,value）映射而来的；那么再写一个字典，由字典<code>d</code>的（value,key）组成，应该就能把python之禅变成代码中的字符串<code>s</code>了。</p><p>把this.py里的代码拿过来改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="string">"""</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">Special cases aren't special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you're Dutch.</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it's a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let's do more of those!</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        <span class="comment"># d[chr(i + c)] = chr((i + 13) % 26 + c)    # 这个是原来的</span></span><br><span class="line">        d[chr((i + <span class="number">13</span>) % <span class="number">26</span> + c)] = chr(i + c)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Gur Mra bs Clguba, ol Gvz Crgref</span><br><span class="line"></span><br><span class="line">Ornhgvshy vf orggre guna htyl.</span><br><span class="line">Rkcyvpvg vf orggre guna vzcyvpvg.</span><br><span class="line">Fvzcyr vf orggre guna pbzcyrk.</span><br><span class="line">Pbzcyrk vf orggre guna pbzcyvpngrq.</span><br><span class="line">Syng vf orggre guna arfgrq.</span><br><span class="line">Fcnefr vf orggre guna qrafr.</span><br><span class="line">Ernqnovyvgl pbhagf.</span><br><span class="line">Fcrpvny pnfrf nera&apos;g fcrpvny rabhtu gb oernx gur ehyrf.</span><br><span class="line">Nygubhtu cenpgvpnyvgl orngf chevgl.</span><br><span class="line">Reebef fubhyq arire cnff fvyragyl.</span><br><span class="line">Hayrff rkcyvpvgyl fvyraprq.</span><br><span class="line">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span><br><span class="line">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span><br><span class="line">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&apos;er Qhgpu.</span><br><span class="line">Abj vf orggre guna arire.</span><br><span class="line">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span><br><span class="line">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg&apos;f n onq vqrn.</span><br><span class="line">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span><br><span class="line">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg&apos;f qb zber bs gubfr!</span><br></pre></td></tr></table></figure><p>跟this.py里的字符串<code>s</code>一致。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>作者是先写下《python之禅》，然后再对其加密生成密文，再写一个解密算法将密文解密显示原文。作者是个老司机！</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>《python之禅》作者用的加密算法是一种简易的替换式密码算法叫做ROT13（回转13位），把字母表中的每个字母用其后的第13 个字母来代替，特征是字母表中前半部分字母将被映射到后半部分，而后半部分字母将被映射到前半部分，大小写保持不变；ROT13 也是过去在古罗马开发的凯撒密码的一种变体。</p><p>其实这种加密算法早就有现成的轮子，要使用可直接用以下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import codecs</span><br><span class="line">&gt;&gt;&gt; codecs.encode(&apos;The Zen of Python&apos;, &apos;rot_13&apos;)</span><br><span class="line">&apos;Gur Mra bs Clguba&apos;</span><br></pre></td></tr></table></figure><p>ROT5/13/18/47加密方式：</p><pre><code>ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。</code></pre><p>编码和加密相关的可参考以下链接：<br><a href="https://www.cnblogs.com/mq0036/p/6544055.html" target="_blank" rel="noopener">https://www.cnblogs.com/mq0036/p/6544055.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
