<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java虚拟机内存</title>
      <link href="/2018/06/23/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/"/>
      <url>/2018/06/23/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>在讨论JVM内存区域分析之前，先来看一下Java程序具体执行的过程：</p><p><img src="/2018/06/23/java虚拟机内存/1.png" alt="Java程序执行过程"></p><blockquote><p>Java 程序的执行过程：</p><p>Java 源代码文件（.Java文件）-&gt; Java Compiler（Java编译器）-&gt;Java 字节码文件（.class文件）-&gt;类加载器（Class Loader）-&gt;Runtime Data Area（运行时数据）-&gt; Execution Engine（执行引擎）。 </p></blockquote><a id="more"></a><p>我们今天就来分析一下Java程序执行过程的 Runtime Data Area（运行时数据）这一块。</p><h3 id="那么运行时数据区包括哪几部分呢？"><a href="#那么运行时数据区包括哪几部分呢？" class="headerlink" title="那么运行时数据区包括哪几部分呢？"></a>那么运行时数据区包括哪几部分呢？</h3><ul><li>程序计数器（Program Counter Register）</li><li>Java虚拟机栈（VM Stack）</li><li>本地方法栈（Native Method Stack）</li><li>方法区（method area）</li><li>堆（heap）</li></ul><h2 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h2><p>　　用来指示程序执行哪一条指令，这跟汇编语言的程序计数器的功能在逻辑上是一样的。JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令地址，如果线程执行的是native方法，则程序计数器中的值undefined。</p><p>　　每个线程都有自己独立的程序计数器。为什么呢？</p><p>　　因为多线程下，一个CPU内核只会执行一条线程中的指令，因此为了使每个线程在线程切换之后能够恢复到切换之前的程序执行的位置，所以每个线程都有自己独立的程序计数器。</p><h2 id="二、Java虚拟机栈"><a href="#二、Java虚拟机栈" class="headerlink" title="二、Java虚拟机栈"></a>二、Java虚拟机栈</h2><p>　　Java虚拟机栈中存放的是一个个栈帧，当程序执行一个方法时，就会创建一个栈帧并压入栈中，当方法执行完毕之后，便会将栈帧移除栈。</p><p>　　我们所说的“栈”是指Java虚拟机栈，一个栈帧中包括：局部变量表、操作数栈、动态连接、方法返回地址、附加信息。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>　　局部变量表主要是存储方法中的局部变量，包括方法中局部变量的信息和方法的参数。如：各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址），其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</p><p>　　局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。</p><blockquote><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li><li>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul></blockquote><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>　　虚拟机把操作数栈作为它的工作区，程序中的所有计算过程都是在借助于操作数栈来完成的，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>　　每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用（指向运行时常量池：在方法执行的过程中有可能需要用到类中的常量），持有这个引用是为了支持方法调用过程中的动态连接。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>　　当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>　　虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</p><h2 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h2><p>　　本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><blockquote><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p></blockquote><h2 id="四、堆（heap）"><a href="#四、堆（heap）" class="headerlink" title="四、堆（heap）"></a>四、堆（heap）</h2><p>　　在C语言中，程序员可以通过malloc函数和free函数在堆上申请和释放空间。那么在Java中是怎么样的呢？Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的），几乎所有的对象实例都在这里分配内存。在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。</p><p>　　另外，堆是被所有线程共享的，在JVM中只有一个堆。</p><h2 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h2><p>　　方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等。</p><p>　　运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><blockquote><p>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。</p></blockquote><p>原文地址：<a href="https://www.jianshu.com/p/4f32f371215d" target="_blank" rel="noopener">https://www.jianshu.com/p/4f32f371215d</a></p>]]></content>
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python对象的真与假</title>
      <link href="/2018/06/21/python%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9C%9F%E4%B8%8E%E5%81%87/"/>
      <url>/2018/06/21/python%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9C%9F%E4%B8%8E%E5%81%87/</url>
      <content type="html"><![CDATA[<h2 id="python中的真假值对照表"><a href="#python中的真假值对照表" class="headerlink" title="python中的真假值对照表"></a>python中的真假值对照表</h2><table><thead><tr><th>类型</th><th style="text-align:center">False</th><th style="text-align:center">True</th></tr></thead><tbody><tr><td>布尔</td><td style="text-align:center">False</td><td style="text-align:center">True</td></tr><tr><td>数值</td><td style="text-align:center">0,   0.0</td><td style="text-align:center">非零的数值</td></tr><tr><td>字符串</td><td style="text-align:center">‘’(空字符串)</td><td style="text-align:center">非空字符串</td></tr><tr><td>容器</td><td style="text-align:center">[],  (),  {},  set()</td><td style="text-align:center">至少有一个元素的容器对象</td></tr><tr><td>None</td><td style="text-align:center">None和某些非None对象</td><td style="text-align:center">大部分非None对象</td></tr></tbody></table><h2 id="非None对象的真假值判断"><a href="#非None对象的真假值判断" class="headerlink" title="非None对象的真假值判断"></a>非None对象的真假值判断</h2><h3 id="bool类介绍"><a href="#bool类介绍" class="headerlink" title="bool类介绍"></a>bool类介绍</h3><p>Python最初是用int来做真假逻辑判断的。在Python 2.3版本中开始引入bool类型（True与False）。</p><p>bool类是int的子类，所以True和False也就相当于1和0。</p><p>下面看一下bool类：</p><pre><code>class bool(int):    &quot;&quot;&quot;    bool(x) -&gt; bool    Returns True when the argument x is true, False otherwise.    The builtins True and False are the only two instances of the class bool.    The class bool is a subclass of the class int, and cannot be subclassed.    &quot;&quot;&quot;</code></pre><blockquote><p>注释翻译：当参数x为真时，返回为真，否则将返回False。真的和假的是类bool的两个实例。类bool是类int的子类，不能被子类化。</p></blockquote><p>打印一下发现，确实是这样的！<br> <img src="/2018/06/21/python对象的真与假/1.png" alt=""></p><h3 id="对象真假值分析"><a href="#对象真假值分析" class="headerlink" title="对象真假值分析"></a>对象真假值分析</h3><p>在做真假逻辑判断时，我们通过if 来判断这个对象的真假时，其实是通过bool()来进行判断的，也就是if a： 相当于if bool(a): ，而if bool(a): 其实是通过对象的<code>__bool__()</code>（python2 中是<code>__nonzero__()</code>）函数或者<code>__len__()</code>的返回值来决定的，下面来看一下<code>__bool__()</code>和<code>__nonzero__()</code>函数的官方文档介绍：</p><ul><li><code>object.__bool__(self)</code></li></ul><blockquote><p>Called to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither<code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p></blockquote><ul><li><code>object.__nonzero__(self)</code></li></ul><blockquote><p>Called to implement truth value testing and the built-in operation bool(); should return False or True, or their integer equivalents 0 or 1. When this method is not defined, <code>__len__()</code>is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code> nor <code>__nonzero__()</code>, all its instances are considered true.</p></blockquote><blockquote><p>有道翻译：要求实现真值测试和内置的bool（）;应该返回False或True。当这个方法没有被定义时，如果它被定义了，len（）就会被调用，如果它的结果是非零的，那么这个对象就被认为是正确的。如果一个类既没有定义len（）也不定义bool（），那么它的所有实例都被认为是正确的。</p></blockquote><p>写一个类重写<code>__bool__()</code>和<code>__len__()</code>试一下：</p><p>先看一下正常的：</p><p><img src="/2018/06/21/python对象的真与假/2.png" alt=""></p><p>重写<code>__bool__()</code>返回False:</p><p><img src="/2018/06/21/python对象的真与假/3.png" alt=""></p><p>重写<code>__bool__()</code>返回True:</p><p><img src="/2018/06/21/python对象的真与假/4.png" alt=""></p><p>重写<code>__len__()</code>返回0:</p><p><img src="/2018/06/21/python对象的真与假/5.png" alt=""></p><p>重写<code>__len__()</code>返回大于0:</p><p><img src="/2018/06/21/python对象的真与假/6.png" alt=""></p><p>重写<code>__len__()</code>返回大于0，<code>__bool__()</code>返回False:</p><p><img src="/2018/06/21/python对象的真与假/7.png" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>__len__()</code>函数对非None对象的真假判断起辅助作用，<code>__bool__()</code>函数起决定作用。</p><p>最后再python官方文档对<code>object.__bool__</code>的介绍：</p><p><a href="https://docs.python.org/3.5/reference/datamodel.html?highlight=__bool__#object.__bool__" target="_blank" rel="noopener">https://docs.python.org/3.5/reference/datamodel.html?highlight=<strong>bool</strong>#object.<strong>bool</strong></a></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>python之禅</title>
      <link href="/2018/06/11/python%E4%B9%8B%E7%A6%85/"/>
      <url>/2018/06/11/python%E4%B9%8B%E7%A6%85/</url>
      <content type="html"><![CDATA[<h3 id="《python之禅》及翻译"><a href="#《python之禅》及翻译" class="headerlink" title="《python之禅》及翻译"></a>《python之禅》及翻译</h3><p>在Python shell中输入<code>import this</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&apos;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&apos;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&apos;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&apos;s do more of those!</span><br></pre></td></tr></table></figure><p>中文翻译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">《python之禅》，Tim Peters著</span><br><span class="line"></span><br><span class="line">优美胜于丑陋</span><br><span class="line">明了胜于晦涩</span><br><span class="line">简洁胜于复杂 </span><br><span class="line">复杂胜于凌乱</span><br><span class="line">扁平胜于嵌套 </span><br><span class="line">间隔胜于紧凑</span><br><span class="line">可读性很重要 </span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则 </span><br><span class="line">不要包容所有错误，除非你确定需要这样做 </span><br><span class="line">当存在多种可能，不要尝试去猜测 </span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案</span><br><span class="line">虽然这并不容易，因为你不是 Python 之父</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做</span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用</span><br></pre></td></tr></table></figure><p>再在Python shell中输入<code>this.__file__</code>找到this.py文件的路径:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>this.__file__</span><br><span class="line"><span class="string">'e:\\python\\Lib\\this.py'</span></span><br></pre></td></tr></table></figure><p>根据路径打开this.py文件，显示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="string">"""Gur Mra bs Clguba, ol Gvz Crgref</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Ornhgvshy vf orggre guna htyl.</span></span><br><span class="line"><span class="string">Rkcyvpvg vf orggre guna vzcyvpvg.</span></span><br><span class="line"><span class="string">Fvzcyr vf orggre guna pbzcyrk.</span></span><br><span class="line"><span class="string">Pbzcyrk vf orggre guna pbzcyvpngrq.</span></span><br><span class="line"><span class="string">Syng vf orggre guna arfgrq.</span></span><br><span class="line"><span class="string">Fcnefr vf orggre guna qrafr.</span></span><br><span class="line"><span class="string">Ernqnovyvgl pbhagf.</span></span><br><span class="line"><span class="string">Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.</span></span><br><span class="line"><span class="string">Nygubhtu cenpgvpnyvgl orngf chevgl.</span></span><br><span class="line"><span class="string">Reebef fubhyq arire cnff fvyragyl.</span></span><br><span class="line"><span class="string">Hayrff rkcyvpvgyl fvyraprq.</span></span><br><span class="line"><span class="string">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span></span><br><span class="line"><span class="string">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span></span><br><span class="line"><span class="string">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.</span></span><br><span class="line"><span class="string">Abj vf orggre guna arire.</span></span><br><span class="line"><span class="string">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span></span><br><span class="line"><span class="string">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        d[chr(i+c)] = chr((i+<span class="number">13</span>) % <span class="number">26</span> + c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br></pre></td></tr></table></figure><p>嗯…</p><h3 id="this-py代码分析"><a href="#this-py代码分析" class="headerlink" title="this.py代码分析"></a>this.py代码分析</h3><p>来分析一些这段代码：</p><ul><li>先是声明了一个字符串变量<code>s</code>，字符串是乱的~，从格式上看跟输入<code>import this</code>显示的一样，感觉上就是把字符串里的每个字符调换了而已；</li><li>然后是声明了一个空字典<code>d</code>，然后写了两层循环对字典进行赋值，chr（）函数是输入一个整数（0，255）返回其对应的ascii值,65对应的ascii码值是’A’,97对应的是’a’,97+26-1=122对应的值是’z’；</li><li>最后是遍历一开始声明的<code>s</code>，把<code>s</code>中的每个字符作为key去取字典<code>d</code>中的value生成一个新的列表，再把这个列表join空字符串””生成一个新的字符串，打印新的字符串，这个新的字符串就是我们输入<code>import this</code>显示出来的《python之禅》。</li></ul><p>嗯，基本上已经知道是怎么实现的了！</p><p>然后打印一下生成后的字典<code>d</code>看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;A&apos;: &apos;N&apos;, &apos;C&apos;: &apos;P&apos;, &apos;B&apos;: &apos;O&apos;, &apos;E&apos;: &apos;R&apos;,</span><br><span class="line"> &apos;D&apos;: &apos;Q&apos;, &apos;G&apos;: &apos;T&apos;, &apos;F&apos;: &apos;S&apos;, &apos;I&apos;: &apos;V&apos;,</span><br><span class="line"> &apos;H&apos;: &apos;U&apos;, &apos;K&apos;: &apos;X&apos;, &apos;J&apos;: &apos;W&apos;, &apos;M&apos;: &apos;Z&apos;,</span><br><span class="line"> &apos;L&apos;: &apos;Y&apos;, &apos;O&apos;: &apos;B&apos;, &apos;N&apos;: &apos;A&apos;, &apos;Q&apos;: &apos;D&apos;,</span><br><span class="line"> &apos;P&apos;: &apos;C&apos;, &apos;S&apos;: &apos;F&apos;, &apos;R&apos;: &apos;E&apos;, &apos;U&apos;: &apos;H&apos;,</span><br><span class="line"> &apos;T&apos;: &apos;G&apos;, &apos;W&apos;: &apos;J&apos;, &apos;V&apos;: &apos;I&apos;, &apos;Y&apos;: &apos;L&apos;,</span><br><span class="line"> &apos;X&apos;: &apos;K&apos;, &apos;Z&apos;: &apos;M&apos;, &apos;a&apos;: &apos;n&apos;, &apos;c&apos;: &apos;p&apos;,</span><br><span class="line"> &apos;b&apos;: &apos;o&apos;, &apos;e&apos;: &apos;r&apos;, &apos;d&apos;: &apos;q&apos;, &apos;g&apos;: &apos;t&apos;,</span><br><span class="line"> &apos;f&apos;: &apos;s&apos;, &apos;i&apos;: &apos;v&apos;, &apos;h&apos;: &apos;u&apos;, &apos;k&apos;: &apos;x&apos;,</span><br><span class="line"> &apos;j&apos;: &apos;w&apos;, &apos;m&apos;: &apos;z&apos;, &apos;l&apos;: &apos;y&apos;, &apos;o&apos;: &apos;b&apos;,</span><br><span class="line"> &apos;n&apos;: &apos;a&apos;, &apos;q&apos;: &apos;d&apos;, &apos;p&apos;: &apos;c&apos;, &apos;s&apos;: &apos;f&apos;,</span><br><span class="line"> &apos;r&apos;: &apos;e&apos;, &apos;u&apos;: &apos;h&apos;, &apos;t&apos;: &apos;g&apos;, &apos;w&apos;: &apos;j&apos;,</span><br><span class="line"> &apos;v&apos;: &apos;i&apos;, &apos;y&apos;: &apos;l&apos;, &apos;x&apos;: &apos;k&apos;, &apos;z&apos;: &apos;m&apos;&#125;</span><br></pre></td></tr></table></figure><p>确实是就一个普通的字典。</p><h3 id="this-py模块s字符串生成"><a href="#this-py模块s字符串生成" class="headerlink" title="this.py模块s字符串生成"></a>this.py模块s字符串生成</h3><p>经过分析：python之禅是由字符串<code>s</code>通过字典<code>d</code>的（key,value）映射而来的；那么再写一个字典，由字典<code>d</code>的（value,key）组成，应该就能把python之禅变成代码中的字符串<code>s</code>了。</p><p>把this.py里的代码拿过来改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s = <span class="string">"""</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">Special cases aren't special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you're Dutch.</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it's a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let's do more of those!</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        <span class="comment"># d[chr(i + c)] = chr((i + 13) % 26 + c)    # 这个是原来的</span></span><br><span class="line">        d[chr((i + <span class="number">13</span>) % <span class="number">26</span> + c)] = chr(i + c)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Gur Mra bs Clguba, ol Gvz Crgref</span><br><span class="line"></span><br><span class="line">Ornhgvshy vf orggre guna htyl.</span><br><span class="line">Rkcyvpvg vf orggre guna vzcyvpvg.</span><br><span class="line">Fvzcyr vf orggre guna pbzcyrk.</span><br><span class="line">Pbzcyrk vf orggre guna pbzcyvpngrq.</span><br><span class="line">Syng vf orggre guna arfgrq.</span><br><span class="line">Fcnefr vf orggre guna qrafr.</span><br><span class="line">Ernqnovyvgl pbhagf.</span><br><span class="line">Fcrpvny pnfrf nera&apos;g fcrpvny rabhtu gb oernx gur ehyrf.</span><br><span class="line">Nygubhtu cenpgvpnyvgl orngf chevgl.</span><br><span class="line">Reebef fubhyq arire cnff fvyragyl.</span><br><span class="line">Hayrff rkcyvpvgyl fvyraprq.</span><br><span class="line">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span><br><span class="line">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span><br><span class="line">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&apos;er Qhgpu.</span><br><span class="line">Abj vf orggre guna arire.</span><br><span class="line">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span><br><span class="line">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg&apos;f n onq vqrn.</span><br><span class="line">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span><br><span class="line">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg&apos;f qb zber bs gubfr!</span><br></pre></td></tr></table></figure><p>跟this.py里的字符串<code>s</code>一致。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>作者是先写下《python之禅》，然后再对其加密生成密文，再写一个解密算法将密文解密显示原文。作者是个老司机！</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>《python之禅》作者用的加密算法是一种简易的替换式密码算法叫做ROT13（回转13位），把字母表中的每个字母用其后的第13 个字母来代替，特征是字母表中前半部分字母将被映射到后半部分，而后半部分字母将被映射到前半部分，大小写保持不变；ROT13 也是过去在古罗马开发的凯撒密码的一种变体。</p><p>其实这种加密算法早就有现成的轮子，要使用可直接用以下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import codecs</span><br><span class="line">&gt;&gt;&gt; codecs.encode(&apos;The Zen of Python&apos;, &apos;rot_13&apos;)</span><br><span class="line">&apos;Gur Mra bs Clguba&apos;</span><br></pre></td></tr></table></figure><p>ROT5/13/18/47加密方式：</p><pre><code>ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。</code></pre><p>编码和加密相关的可参考以下链接：<br><a href="https://www.cnblogs.com/mq0036/p/6544055.html" target="_blank" rel="noopener">https://www.cnblogs.com/mq0036/p/6544055.html</a></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
